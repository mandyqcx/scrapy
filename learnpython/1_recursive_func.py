'''递归函数:在函数内部调用自己的函数'''

#%%计算阶乘n!,f(n)=n!=1*2*3*4*...*(n-1)*n=f(n-1)*n,f(n)可以表示为n*f(n-1),只有n=1时需要特殊处理
def f(n):
    if n==1:
        return 1
    return n*f(n-1)

f(5)


#理论上所有的递归函数都可以写成循环的方式

#%%使用递归函数需要防止栈溢出，在计算机中，函数调用是使用栈(satck)这种数据结果实现的，每当进入一个函数调用，栈就会加一个栈帧，返回，栈就会减一个栈帧，
#所以当递归调用次数过多的时候，会导致栈溢出
#解决递归调用栈溢出的方法是通过尾递归优化，尾递归是指，在函数返回的时候，调用函数本身，并且return语句不能包含表达式，
# 解释器如果这样对尾递归做优化，使递归本身多少次，都只占用一个帧栈，不会出现栈溢出的情况
#但是大多数语言是没有针对尾递归做优化，Python也没有，所以尾递归的方式还是会导致栈溢出
def f(n):
    return fn(n-1)

def fn(n,result):
    if n==1:
        return result
    return fn(n-1,n*result)


#%%请编写move(n, a, b, c)函数，它接收参数n，表示3个柱子A、B、C中第1个柱子A的盘子数量，然后打印出把所有盘子从A借助B移动到C的方法
def move(n,a,b,c):
    if n==1:
        print(a,'-->',c)
    else:
        move(n-1,a,c,b)
        print(a,'-->',c)
        move(n-1,b,a,c)

move(3,'A','B','C')
